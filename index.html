<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>ƒê√™m Tƒ©nh L·∫∑ng & L·ªìng ƒê√®n ∆Ø·ªõc Nguy·ªán</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      margin: 0;
      padding: 0;
      background: black;
      font-family: "Segoe UI", sans-serif;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #controls {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #wishInput {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      outline: none;
      font-size: 16px;
      width: 220px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
    }

    #wishInput::placeholder {
      color: rgba(255,255,255,0.5);
    }

    button {
      background: rgba(255, 165, 0, 0.85);
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      outline: none;
      font-size: 16px;
      width: 220px;
      color: white;
      text-align: center;
    }

    button:hover {
      background: rgba(255, 200, 60, 1);
      transform: scale(1.05);
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <div id="controls">
    <input id="wishInput" placeholder="Nh·∫≠p l·ªùi ∆∞·ªõc..." />
    <button id="startBtn">üå† Th·∫£ l·ªìng ƒë√®n üå†</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- N·ªÅn ƒë√™m ---
    function drawBackground() {
      const gradient = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        100,
        canvas.width / 2,
        canvas.height / 2,
        canvas.height
      );
      gradient.addColorStop(0, 'rgb(30,30,40)');
      gradient.addColorStop(0.3, 'rgb(15,15,25)');
      gradient.addColorStop(1, 'rgb(5,5,15)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // --- M·∫∑t trƒÉng ---
    function drawMoon() {
      const moonX = canvas.width * 0.8;
      const moonY = canvas.height * 0.2;
      const moonR = 60;

      const glow = ctx.createRadialGradient(moonX, moonY, moonR * 0.5, moonX, moonY, moonR * 2);
      glow.addColorStop(0, "rgba(255, 255, 200, 0.8)");
      glow.addColorStop(0.3, "rgba(255, 255, 170, 0.4)");
      glow.addColorStop(1, "rgba(255, 255, 150, 0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(moonX, moonY, moonR * 2, 0, Math.PI * 2);
      ctx.fill();

      const moonGradient = ctx.createRadialGradient(moonX - 10, moonY - 10, moonR * 0.5, moonX, moonY, moonR);
      moonGradient.addColorStop(0, "rgb(255,255,220)");
      moonGradient.addColorStop(1, "rgb(240,230,150)");
      ctx.fillStyle = moonGradient;
      ctx.beginPath();
      ctx.arc(moonX, moonY, moonR, 0, Math.PI * 2);
      ctx.fill();
    }

    // --- B√≥ng n√∫i ---
    function drawMountains() {
    ctx.save();
    ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
    ctx.beginPath();

    // B·∫Øt ƒë·∫ßu th·∫•p ngo√†i m√©p tr√°i
    ctx.moveTo(-100, canvas.height);

    // V·∫Ω d√£y n√∫i ch·∫°y qua to√†n m√†n h√¨nh, th√™m v√πng tr√†n ph·∫£i ƒë·ªÉ kh√¥ng b·ªã khuy·∫øt
    for (let i = -100; i <= canvas.width + 100; i += 50) {
        const height = Math.sin(i * 0.005) * 60 + 120;
        ctx.lineTo(i, canvas.height * 0.8 - height);
    }

    // K√©o xu·ªëng m√©p ph·∫£i v√† ƒë√≥ng k√≠n
    ctx.lineTo(canvas.width + 100, canvas.height);
    ctx.lineTo(-100, canvas.height);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
    }
    // --- Sao tƒ©nh ---
    const stars = [];
    for (let i = 0; i < 150; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * 0.7,
        r: Math.random() * 2 + 0.5,
        alpha: Math.random(),
        delta: Math.random() * 0.02 + 0.005
      });
    }

    function drawStars() {
      for (const s of stars) {
        s.alpha += s.delta;
        if (s.alpha <= 0 || s.alpha >= 1) s.delta = -s.delta;
        ctx.globalAlpha = s.alpha;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.shadowBlur = 6;
        ctx.shadowColor = "white";
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }

    // --- Sao bƒÉng ---
    class ShootingStar {
      constructor() { this.reset(); }
      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height * 0.4;
        this.len = Math.random() * 80 + 100;
        this.speed = Math.random() * 6 + 2;
        this.angle = (3 * Math.PI) / 4 + (Math.random() * 0.2 - 0.1);
        this.alpha = 1;
        this.life = 0;
        this.maxLife = 60 + Math.random() * 40;
      }
      update() {
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life++;
        this.alpha = 1 - this.life / this.maxLife;
        if (this.life >= this.maxLife) this.reset();
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        ctx.shadowColor = "white";
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(
          this.x - Math.cos(this.angle) * this.len,
          this.y - Math.sin(this.angle) * this.len
        );
        ctx.stroke();
        ctx.restore();
      }
    }
    const shootingStars = Array.from({ length: 3 }, () => new ShootingStar());

    // --- M√¢y m∆∞·ª£t ---
class Cloud {
  constructor() {
    this.x = Math.random() * canvas.width;
    // üëá M√¢y cao h∆°n: xu·∫•t hi·ªán trong v√πng g·∫ßn trƒÉng (20%‚Äì45% chi·ªÅu cao)
    this.y = canvas.height * 0.15 + Math.random() * (canvas.height * 0.3);
    this.size = Math.random() * 50 + 50;
    this.speed = Math.random() * 0.08 + 0.03;
    this.alpha = Math.random() * 0.25 + 0.2;
    this.offsets = [];

    const segments = 5 + Math.floor(Math.random() * 3);
    for (let i = 0; i < segments; i++) {
      const offsetX = (i - segments / 2) * (this.size / 2);
      const offsetY = (Math.random() - 0.5) * this.size * 0.2;
      const radiusX = this.size * (0.5 + Math.random() * 0.3);
      const radiusY = radiusX * (0.6 + Math.random() * 0.2);
      this.offsets.push({ offsetX, offsetY, radiusX, radiusY });
    }

    this.floatPhase = Math.random() * Math.PI * 2;
  }

  update() {
    this.x += this.speed;
    this.floatPhase += 0.002;
    if (this.x > canvas.width + this.size * 2) {
      this.x = -this.size * 2;
      // üëá Khi reset c≈©ng cho m√¢y bay l·∫°i v√πng cao
      this.y = canvas.height * 0.15 + Math.random() * (canvas.height * 0.3);
    }
  }

  draw() {
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
    ctx.shadowBlur = 20;
    ctx.shadowColor = "rgba(255, 255, 255, 0.5)";
    ctx.beginPath();
    const floatY = Math.sin(this.floatPhase) * 5;
    for (const p of this.offsets) {
      ctx.ellipse(
        this.x + p.offsetX,
        this.y + p.offsetY + floatY,
        p.radiusX,
        p.radiusY,
        0,
        0,
        Math.PI * 2
      );
    }
    ctx.fill();
    ctx.restore();
  }
}

    const clouds = Array.from({ length: 5 }, () => new Cloud());

    // --- ·∫¢nh l·ªìng ƒë√®n ---
    const lanternImg = new Image();
    lanternImg.src = "images/l1.png";

    // --- L·ªìng ƒë√®n ---
    class Lantern {
      constructor(x, y, wish = "") {
        this.x = x;
        this.y = y;
        this.speed = Math.random() * 0.5 + 0.3;
        this.size = Math.random() * 0.08 + 0.08;
        this.swingAngle = Math.random() * Math.PI * 2;
        this.swingSpeed = Math.random() * 0.01 + 0.005;
        this.wish = wish;
        this.trail = [];
        this.alpha = 0;
      }
      update() {
        this.y -= this.speed;
        this.swingAngle += this.swingSpeed;
        this.x += Math.sin(this.swingAngle) * 0.4;
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 12) this.trail.shift();
        if (this.alpha < 1) this.alpha += 0.01;
      }
      draw() {
        if (!lanternImg.complete) return;
        const w = lanternImg.width * this.size;
        const h = lanternImg.height * this.size;

        // ƒêu√¥i s√°ng
        ctx.save();
        ctx.globalAlpha = this.alpha * 0.6;
        ctx.strokeStyle = "rgba(255,200,120,0.15)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let i = 0; i < this.trail.length - 1; i++) {
          const t = this.trail[i];
          const n = this.trail[i + 1];
          ctx.moveTo(t.x, t.y);
          ctx.lineTo(n.x, n.y);
        }
        ctx.stroke();
        ctx.restore();

        // √Ånh s√°ng quanh ƒë√®n
        const glowRadius = w * 1.1;
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRadius);
        gradient.addColorStop(0, "rgba(255,220,150,0.5)");
        gradient.addColorStop(0.4, "rgba(255,180,100,0.2)");
        gradient.addColorStop(1, "rgba(255,140,50,0)");
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = this.alpha * 0.9;
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // L·ªìng ƒë√®n
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.shadowBlur = 15;
        ctx.shadowColor = "rgba(255,180,80,0.8)";
        ctx.drawImage(lanternImg, this.x - w / 2, this.y - h / 2, w, h);
        ctx.restore();

        // L·ªùi ∆∞·ªõc
        if (this.wish) {
          ctx.save();
          ctx.globalAlpha = this.alpha * 0.9;
          ctx.font = `${18 * this.size * 10}px "Segoe UI"`;
          ctx.fillStyle = "rgba(255,230,180,0.85)";
          ctx.textAlign = "center";
          ctx.fillText(this.wish, this.x, this.y - h / 2 - 10);
          ctx.restore();
        }
      }
    }

    let lanterns = [];

    // --- Animation ---
    function animate() {
      ctx.fillStyle = "rgba(0, 0, 10, 0.3)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawBackground();
      drawMoon();
      drawStars();

      for (const cloud of clouds) { cloud.update(); cloud.draw(); }
      for (const s of shootingStars) { s.update(); s.draw(); }

      drawMountains();

      for (const l of lanterns) { l.update(); l.draw(); }
      lanterns = lanterns.filter(l => l.y + 100 > 0);

      requestAnimationFrame(animate);
    }

    const startBtn = document.getElementById("startBtn");
    const wishInput = document.getElementById("wishInput");

    startBtn.addEventListener("click", () => {
      const wishText = wishInput.value.trim() || "";
      for (let i = 0; i < 4; i++) {
        lanterns.push(new Lantern(
          Math.random() * canvas.width,
          canvas.height * 0.8 + Math.random() * 50,
          wishText
        ));
      }
      wishInput.value = "";
    });

    drawBackground();
    drawMoon();
    drawStars();
    animate();

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
